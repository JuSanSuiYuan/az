# AZ语言中的所有权管理与AZGC（待实现）

注意: AZ语言的开源仓库目前正在准备中，计划托管在 https://gitee.com/az_lang/az，请勿执行git clone操作。

## 概述

本文档描述了AZ语言计划中的混合内存管理模式，该模式将所有权系统和垃圾回收器(AZGC)分离使用，根据不同场景自动或手动选择最适合的内存管理方式。**当前版本暂不实现所有权管理系统和AZGC功能，这些功能计划在未来的版本中实现。**

## 核心理念（计划中）

AZGC作为内存管理的"最后一道防线"，而不是常规回收机制，与所有权管理形成互补关系。GC不应该与所有权管理竞争，而应该弥补其不足。这种设计理念确保了：

1. **默认性能优先**：在大多数情况下使用高效的所有权管理
2. **安全保障兜底**：在复杂场景中使用GC处理所有权难以解决的问题
3. **灵活适应场景**：根据不同应用需求自动或手动选择最适合的内存管理方式

## 灵活的集成方式（计划中）

借鉴Oilpan等成功案例的经验，AZ语言计划采用模块化设计，提供灵活的内存管理组件集成方式：

1. **模块化的内存管理组件**：AZGC以库的形式提供，开发者可以根据项目需求选择是否集成
2. **按需启用**：支持在项目的特定模块或组件中启用GC，而非全局启用
3. **多环境集成支持**：可与不同的运行时环境集成，适应各种应用场景

## 所有权管理系统（计划中）

### 核心特性
- **默认启用**：AZ语言计划默认使用所有权系统管理内存
- **编译时检查**：在编译期确保内存安全，防止悬空指针和内存泄漏
- **零运行时开销**：不引入额外的运行时负担
- **确定性析构**：对象生命周期明确，析构时机可预测

### 适用场景
1. **系统编程**：操作系统、驱动程序、嵌入式系统
2. **实时系统**：对响应时间有严格要求的应用
3. **高性能计算**：需要确定性性能表现的场景
4. **资源受限环境**：内存或CPU资源有限的设备

## AZGC垃圾回收器（计划中）

### 核心特性
- **按需启用**：仅在需要时启用，非默认选项
- **超低延迟**：亚毫秒级停顿时间，最大程度减少对应用的影响
- **并发执行**：应用程序线程与GC线程可同时运行
- **智能调优**：根据应用特征自动优化回收策略

### 适用场景
1. **复杂数据结构**：存在循环引用或难以静态分析的对象关系
2. **应用开发**：Web服务、桌面应用等对开发效率要求较高的场景
3. **快速原型开发**：需要快速迭代而不想处理复杂内存管理的项目
4. **脚本编写**：临时脚本或工具程序

## 分离使用策略（计划中）

### 自动选择机制
AZ编译器会根据以下因素自动判断使用哪种内存管理模式：

#### 使用所有权系统的情况
- 对象生命周期明确且可静态分析
- 不存在循环引用或复杂图结构
- 在实时系统或高性能计算场景中
- 在资源受限环境中

#### 使用AZGC的情况
- 存在循环引用或复杂对象图
- 对象生命周期难以静态确定
- 在应用开发或快速原型开发中
- 开发者明确选择启用GC

### 手动控制选项
开发者可以通过以下方式手动控制内存管理模式：

1. **模块级别控制**：
   ```az
   // 在模块顶部指定使用GC
   #gc on
   
   // 或指定禁用GC，仅使用所有权管理
   #gc off
   ```

2. **作用域级别控制**：
   ```az
   // 在特定作用域中启用GC
   gc_scope {
       // 此作用域内的对象由AZGC管理
   }
   
   // 默认作用域使用所有权管理
   ```

3. **对象级别控制**：
   ```az
   // 明确指定对象使用GC管理
   var gc_obj = gc_alloc(MyObject);
   
   // 默认使用所有权管理
   var owned_obj = MyObject();
   ```

## GC触发策略（计划中）

### 三大关键触发场景

#### 场景一：所有权管理无法处理的"僵局"
这类场景是所有权管理的"天敌"，必须依靠GC来打破僵局。

- **循环引用**：如双向链表、父子节点相互引用等
- **复杂图结构**：ORM缓存、依赖注入容器等

#### 场景二：性能与效率的权衡
这类场景下，所有权管理在理论上是可行的，但在实践中有性能代价。

- **高频小对象**：函数式编程中间数据、虚拟机临时值等
- **对象池化场景**：连接池、对象缓存等

#### 场景三：安全性与稳健性保障
这类场景下，GC作为一种"安全网"，防止资源泄漏。

- **与非托管代码交互**：JNI、P/Invoke等
- **生命周期误判兜底**：异步/多线程编程中的错误

### 不适合触发AZGC的场景
1. **实时系统与高性能计算**
   - 硬实时控制（工业机器人、自动驾驶等）
   - 高频金融交易（微秒级股票交易）
   - 科学计算与模拟（大规模数值计算）

2. **关键事务处理**
   - 数据库事务提交
   - 分布式系统共识（Raft、Paxos协议等）
   - 支付与结算系统

3. **资源受限与环境敏感场景**
   - 低电量设备（手机、IoT设备）
   - 内存极度紧张时
   - 启动与初始化阶段

4. **用户交互与界面响应**
   - 用户输入处理
   - UI动画执行过程

## 最佳实践（计划中）

1. **默认策略**：新项目默认使用所有权管理，仅在必要时启用AZGC
2. **性能监控**：持续监控内存使用模式和GC行为，及时调整策略
3. **混合模式**：在同一项目中不同模块使用不同的内存管理模式
4. **明确标识**：在代码中明确标识哪些部分使用GC，提高可维护性

## 总结

AZ语言计划中的混合内存管理模式允许开发者在同一个项目中充分利用两种内存管理机制的优势。所有权系统提供了确定性和高性能，适用于系统编程和实时应用；AZGC提供了便利性和安全性，适用于复杂应用开发。通过智能的自动选择机制和灵活的手动控制选项，AZ语言能够在各种场景下提供最佳的内存管理方案。