// std.collections.HashMap - 哈希表
// 版本: v1.0.0
// 日期: 2025-10-30

module std.collections.hashmap;

import std.error.{Result, Option};
import std.collections.vec.Vec;

// ============================================================================
// C标准库接口
// ============================================================================

extern "C" {
    fn malloc(size: int) *void;
    fn free(ptr: *void) void;
    fn memset(s: *void, c: int, n: int) *void;
}

// ============================================================================
// 哈希表节点
// ============================================================================

struct HashMapEntry<K, V> {
    key: K,
    value: V,
    hash: int,
    next: *HashMapEntry<K, V>
}

// ============================================================================
// HashMap<K, V> - 哈希表
// ============================================================================

/// 哈希表类型
pub struct HashMap<K, V> {
    buckets: **HashMapEntry<K, V>,
    bucket_count: int,
    size: int,
    load_factor: float
}

// ============================================================================
// 构造函数
// ============================================================================

/// 创建新的HashMap
pub fn new<K, V>() HashMap<K, V> {
    return with_capacity<K, V>(16);
}

/// 创建指定容量的HashMap
pub fn with_capacity<K, V>(capacity: int) HashMap<K, V> {
    if (capacity < 4) capacity = 4;
    
    let buckets = malloc(capacity * sizeof(*HashMapEntry<K, V>)) as **HashMapEntry<K, V>;
    memset(buckets as *void, 0, capacity * sizeof(*HashMapEntry<K, V>));
    
    return HashMap<K, V> {
        buckets: buckets,
        bucket_count: capacity,
        size: 0,
        load_factor: 0.75
    };
}

// ============================================================================
// 哈希函数
// ============================================================================

/// 计算哈希值（简化版）
fn hash<K>(key: K) int {
    // 简化实现：假设K可以转换为int
    // 实际应该根据类型实现不同的哈希函数
    let ptr = &key as *int;
    var h = *ptr;
    
    // 简单的哈希混合
    h = h ^ (h >> 16);
    h = h * 0x85ebca6b;
    h = h ^ (h >> 13);
    h = h * 0xc2b2ae35;
    h = h ^ (h >> 16);
    
    return h;
}

/// 获取桶索引
fn bucket_index(hash: int, bucket_count: int) int {
    return (hash & 0x7fffffff) % bucket_count;
}

// ============================================================================
// 基础操作
// ============================================================================

/// 获取大小
pub fn (self: *HashMap<K, V>) len() int {
    return self.size;
}

/// 检查是否为空
pub fn (self: *HashMap<K, V>) is_empty() bool {
    return self.size == 0;
}

/// 清空HashMap
pub fn (self: *HashMap<K, V>) clear() void {
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            let next = current.next;
            free(current);
            current = next;
        }
        self.buckets[i] = null;
    }
    self.size = 0;
}

// ============================================================================
// 扩容
// ============================================================================

/// 扩容
fn (self: *HashMap<K, V>) resize() void {
    let new_bucket_count = self.bucket_count * 2;
    let new_buckets = malloc(new_bucket_count * sizeof(*HashMapEntry<K, V>)) as **HashMapEntry<K, V>;
    memset(new_buckets as *void, 0, new_bucket_count * sizeof(*HashMapEntry<K, V>));
    
    // 重新哈希所有元素
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            let next = current.next;
            
            // 计算新的桶索引
            let new_index = bucket_index(current.hash, new_bucket_count);
            
            // 插入到新桶
            current.next = new_buckets[new_index];
            new_buckets[new_index] = current;
            
            current = next;
        }
    }
    
    // 释放旧桶数组
    free(self.buckets);
    
    self.buckets = new_buckets;
    self.bucket_count = new_bucket_count;
}

// ============================================================================
// 插入和获取
// ============================================================================

/// 插入键值对
pub fn (self: *HashMap<K, V>) insert(key: K, value: V) Option<V> {
    let h = hash(key);
    let index = bucket_index(h, self.bucket_count);
    
    // 查找是否已存在
    var current = self.buckets[index];
    while (current != null) {
        if (current.hash == h && current.key == key) {
            // 更新值
            let old_value = current.value;
            current.value = value;
            return Option.Some(old_value);
        }
        current = current.next;
    }
    
    // 检查是否需要扩容
    if (self.size as float >= self.bucket_count as float * self.load_factor) {
        self.resize();
        index = bucket_index(h, self.bucket_count);
    }
    
    // 创建新节点
    let entry = malloc(sizeof(HashMapEntry<K, V>)) as *HashMapEntry<K, V>;
    entry.key = key;
    entry.value = value;
    entry.hash = h;
    entry.next = self.buckets[index];
    
    self.buckets[index] = entry;
    self.size = self.size + 1;
    
    return Option.None;
}

/// 获取值
pub fn (self: *HashMap<K, V>) get(key: K) Option<V> {
    let h = hash(key);
    let index = bucket_index(h, self.bucket_count);
    
    var current = self.buckets[index];
    while (current != null) {
        if (current.hash == h && current.key == key) {
            return Option.Some(current.value);
        }
        current = current.next;
    }
    
    return Option.None;
}

/// 获取可变引用
pub fn (self: *HashMap<K, V>) get_mut(key: K) Option<*V> {
    let h = hash(key);
    let index = bucket_index(h, self.bucket_count);
    
    var current = self.buckets[index];
    while (current != null) {
        if (current.hash == h && current.key == key) {
            return Option.Some(&current.value);
        }
        current = current.next;
    }
    
    return Option.None;
}

/// 检查是否包含键
pub fn (self: *HashMap<K, V>) contains_key(key: K) bool {
    return self.get(key).is_some();
}

// ============================================================================
// 删除
// ============================================================================

/// 移除键值对
pub fn (self: *HashMap<K, V>) remove(key: K) Option<V> {
    let h = hash(key);
    let index = bucket_index(h, self.bucket_count);
    
    var current = self.buckets[index];
    var prev: *HashMapEntry<K, V> = null;
    
    while (current != null) {
        if (current.hash == h && current.key == key) {
            let value = current.value;
            
            // 从链表中移除
            if (prev == null) {
                self.buckets[index] = current.next;
            } else {
                prev.next = current.next;
            }
            
            free(current);
            self.size = self.size - 1;
            return Option.Some(value);
        }
        
        prev = current;
        current = current.next;
    }
    
    return Option.None;
}

// ============================================================================
// 迭代
// ============================================================================

/// 获取所有键
pub fn (self: *HashMap<K, V>) keys() Vec<K> {
    let result = Vec<K>.with_capacity(self.size);
    
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            result.push(current.key);
            current = current.next;
        }
    }
    
    return result;
}

/// 获取所有值
pub fn (self: *HashMap<K, V>) values() Vec<V> {
    let result = Vec<V>.with_capacity(self.size);
    
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            result.push(current.value);
            current = current.next;
        }
    }
    
    return result;
}

/// 获取所有键值对
pub fn (self: *HashMap<K, V>) entries() Vec<(K, V)> {
    let result = Vec<(K, V)>.with_capacity(self.size);
    
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            result.push((current.key, current.value));
            current = current.next;
        }
    }
    
    return result;
}

/// 对每个键值对执行函数
pub fn (self: *HashMap<K, V>) for_each(f: fn(K, V) void) void {
    for (var i = 0; i < self.bucket_count; i = i + 1) {
        var current = self.buckets[i];
        while (current != null) {
            f(current.key, current.value);
            current = current.next;
        }
    }
}

// ============================================================================
// 内存管理
// ============================================================================

/// 释放HashMap的内存
pub fn (self: *HashMap<K, V>) drop() void {
    self.clear();
    if (self.buckets != null) {
        free(self.buckets);
        self.buckets = null;
    }
    self.bucket_count = 0;
}

// ============================================================================
// 辅助函数
// ============================================================================

extern fn sizeof<T>() int;
