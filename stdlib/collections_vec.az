// std.collections.Vec - 动态数组
// 版本: v1.0.0
// 日期: 2025-10-30

module std.collections.vec;

import std.error.{Result, Option};
import std.mem;

// ============================================================================
// C标准库接口
// ============================================================================

extern "C" {
    fn malloc(size: int) *void;
    fn realloc(ptr: *void, size: int) *void;
    fn free(ptr: *void) void;
    fn memcpy(dest: *void, src: *void, n: int) *void;
    fn memmove(dest: *void, src: *void, n: int) *void;
    fn memset(s: *void, c: int, n: int) *void;
}

// ============================================================================
// Vec<T> - 动态数组
// ============================================================================

/// 动态数组类型
pub struct Vec<T> {
    data: *T,
    len: int,
    capacity: int
}

// ============================================================================
// 构造函数
// ============================================================================

/// 创建新的空Vec
pub fn new<T>() Vec<T> {
    return Vec<T> {
        data: null,
        len: 0,
        capacity: 0
    };
}

/// 创建指定容量的Vec
pub fn with_capacity<T>(capacity: int) Vec<T> {
    if (capacity <= 0) {
        return new<T>();
    }
    
    let data = malloc(capacity * sizeof<T>()) as *T;
    return Vec<T> {
        data: data,
        len: 0,
        capacity: capacity
    };
}

/// 从数组创建Vec
pub fn from_array<T>(arr: []T, len: int) Vec<T> {
    let vec = with_capacity<T>(len);
    
    for (var i = 0; i < len; i = i + 1) {
        vec.push(arr[i]);
    }
    
    return vec;
}

// ============================================================================
// 基础操作
// ============================================================================

/// 获取长度
pub fn (self: *Vec<T>) len() int {
    return self.len;
}

/// 获取容量
pub fn (self: *Vec<T>) capacity() int {
    return self.capacity;
}

/// 检查是否为空
pub fn (self: *Vec<T>) is_empty() bool {
    return self.len == 0;
}

/// 清空Vec
pub fn (self: *Vec<T>) clear() void {
    self.len = 0;
}

/// 扩容
fn (self: *Vec<T>) grow() void {
    let new_capacity = if (self.capacity == 0) 4 else self.capacity * 2;
    
    if (self.data == null) {
        self.data = malloc(new_capacity * sizeof<T>()) as *T;
    } else {
        self.data = realloc(self.data, new_capacity * sizeof<T>()) as *T;
    }
    
    self.capacity = new_capacity;
}

/// 确保容量足够
pub fn (self: *Vec<T>) reserve(additional: int) void {
    let required = self.len + additional;
    if (required > self.capacity) {
        let new_capacity = if (self.capacity == 0) 4 else self.capacity;
        while (new_capacity < required) {
            new_capacity = new_capacity * 2;
        }
        
        if (self.data == null) {
            self.data = malloc(new_capacity * sizeof<T>()) as *T;
        } else {
            self.data = realloc(self.data, new_capacity * sizeof<T>()) as *T;
        }
        
        self.capacity = new_capacity;
    }
}

// ============================================================================
// 添加和删除
// ============================================================================

/// 在末尾添加元素
pub fn (self: *Vec<T>) push(item: T) void {
    if (self.len >= self.capacity) {
        self.grow();
    }
    
    self.data[self.len] = item;
    self.len = self.len + 1;
}

/// 移除并返回最后一个元素
pub fn (self: *Vec<T>) pop() Option<T> {
    if (self.len == 0) {
        return Option.None;
    }
    
    self.len = self.len - 1;
    return Option.Some(self.data[self.len]);
}

/// 在指定位置插入元素
pub fn (self: *Vec<T>) insert(index: int, item: T) bool {
    if (index < 0 || index > self.len) {
        return false;
    }
    
    if (self.len >= self.capacity) {
        self.grow();
    }
    
    // 移动元素
    if (index < self.len) {
        memmove(
            (self.data + index + 1) as *void,
            (self.data + index) as *void,
            (self.len - index) * sizeof<T>()
        );
    }
    
    self.data[index] = item;
    self.len = self.len + 1;
    return true;
}

/// 移除指定位置的元素
pub fn (self: *Vec<T>) remove(index: int) Option<T> {
    if (index < 0 || index >= self.len) {
        return Option.None;
    }
    
    let item = self.data[index];
    
    // 移动元素
    if (index < self.len - 1) {
        memmove(
            (self.data + index) as *void,
            (self.data + index + 1) as *void,
            (self.len - index - 1) * sizeof<T>()
        );
    }
    
    self.len = self.len - 1;
    return Option.Some(item);
}

/// 交换移除（更快，但不保持顺序）
pub fn (self: *Vec<T>) swap_remove(index: int) Option<T> {
    if (index < 0 || index >= self.len) {
        return Option.None;
    }
    
    let item = self.data[index];
    
    // 用最后一个元素替换
    if (index < self.len - 1) {
        self.data[index] = self.data[self.len - 1];
    }
    
    self.len = self.len - 1;
    return Option.Some(item);
}

// ============================================================================
// 访问元素
// ============================================================================

/// 获取指定位置的元素
pub fn (self: *Vec<T>) get(index: int) Option<T> {
    if (index < 0 || index >= self.len) {
        return Option.None;
    }
    return Option.Some(self.data[index]);
}

/// 获取指定位置的元素（不安全，不检查边界）
pub fn (self: *Vec<T>) get_unchecked(index: int) T {
    return self.data[index];
}

/// 设置指定位置的元素
pub fn (self: *Vec<T>) set(index: int, item: T) bool {
    if (index < 0 || index >= self.len) {
        return false;
    }
    self.data[index] = item;
    return true;
}

/// 获取第一个元素
pub fn (self: *Vec<T>) first() Option<T> {
    if (self.len == 0) {
        return Option.None;
    }
    return Option.Some(self.data[0]);
}

/// 获取最后一个元素
pub fn (self: *Vec<T>) last() Option<T> {
    if (self.len == 0) {
        return Option.None;
    }
    return Option.Some(self.data[self.len - 1]);
}

// ============================================================================
// 查找
// ============================================================================

/// 查找元素的位置
pub fn (self: *Vec<T>) find(item: T) Option<int> {
    for (var i = 0; i < self.len; i = i + 1) {
        if (self.data[i] == item) {
            return Option.Some(i);
        }
    }
    return Option.None;
}

/// 检查是否包含元素
pub fn (self: *Vec<T>) contains(item: T) bool {
    return self.find(item).is_some();
}

/// 从后往前查找
pub fn (self: *Vec<T>) rfind(item: T) Option<int> {
    for (var i = self.len - 1; i >= 0; i = i - 1) {
        if (self.data[i] == item) {
            return Option.Some(i);
        }
    }
    return Option.None;
}

// ============================================================================
// 迭代和转换
// ============================================================================

/// 对每个元素执行函数
pub fn (self: *Vec<T>) for_each(f: fn(T) void) void {
    for (var i = 0; i < self.len; i = i + 1) {
        f(self.data[i]);
    }
}

/// 映射到新Vec
pub fn (self: *Vec<T>) map<U>(f: fn(T) U) Vec<U> {
    let result = with_capacity<U>(self.len);
    
    for (var i = 0; i < self.len; i = i + 1) {
        result.push(f(self.data[i]));
    }
    
    return result;
}

/// 过滤元素
pub fn (self: *Vec<T>) filter(f: fn(T) bool) Vec<T> {
    let result = new<T>();
    
    for (var i = 0; i < self.len; i = i + 1) {
        if (f(self.data[i])) {
            result.push(self.data[i]);
        }
    }
    
    return result;
}

/// 折叠（reduce）
pub fn (self: *Vec<T>) fold<U>(init: U, f: fn(U, T) U) U {
    var acc = init;
    
    for (var i = 0; i < self.len; i = i + 1) {
        acc = f(acc, self.data[i]);
    }
    
    return acc;
}

/// 检查是否所有元素满足条件
pub fn (self: *Vec<T>) all(f: fn(T) bool) bool {
    for (var i = 0; i < self.len; i = i + 1) {
        if (!f(self.data[i])) {
            return false;
        }
    }
    return true;
}

/// 检查是否有元素满足条件
pub fn (self: *Vec<T>) any(f: fn(T) bool) bool {
    for (var i = 0; i < self.len; i = i + 1) {
        if (f(self.data[i])) {
            return true;
        }
    }
    return false;
}

// ============================================================================
// 排序和反转
// ============================================================================

/// 反转Vec
pub fn (self: *Vec<T>) reverse() void {
    var left = 0;
    var right = self.len - 1;
    
    while (left < right) {
        let temp = self.data[left];
        self.data[left] = self.data[right];
        self.data[right] = temp;
        
        left = left + 1;
        right = right - 1;
    }
}

/// 排序（简单冒泡排序）
pub fn (self: *Vec<T>) sort() void {
    for (var i = 0; i < self.len - 1; i = i + 1) {
        for (var j = 0; j < self.len - i - 1; j = j + 1) {
            if (self.data[j] > self.data[j + 1]) {
                let temp = self.data[j];
                self.data[j] = self.data[j + 1];
                self.data[j + 1] = temp;
            }
        }
    }
}

/// 使用比较函数排序
pub fn (self: *Vec<T>) sort_by(cmp: fn(T, T) int) void {
    for (var i = 0; i < self.len - 1; i = i + 1) {
        for (var j = 0; j < self.len - i - 1; j = j + 1) {
            if (cmp(self.data[j], self.data[j + 1]) > 0) {
                let temp = self.data[j];
                self.data[j] = self.data[j + 1];
                self.data[j + 1] = temp;
            }
        }
    }
}

// ============================================================================
// 切片和转换
// ============================================================================

/// 获取切片
pub fn (self: *Vec<T>) slice(start: int, end: int) Vec<T> {
    if (start < 0) start = 0;
    if (end > self.len) end = self.len;
    if (start >= end) return new<T>();
    
    let result = with_capacity<T>(end - start);
    
    for (var i = start; i < end; i = i + 1) {
        result.push(self.data[i]);
    }
    
    return result;
}

/// 转换为数组
pub fn (self: *Vec<T>) to_array() []T {
    // 返回内部数组的引用
    return self.data[0:self.len];
}

/// 克隆Vec
pub fn (self: *Vec<T>) clone() Vec<T> {
    let result = with_capacity<T>(self.len);
    
    if (self.len > 0) {
        memcpy(
            result.data as *void,
            self.data as *void,
            self.len * sizeof<T>()
        );
        result.len = self.len;
    }
    
    return result;
}

// ============================================================================
// 内存管理
// ============================================================================

/// 收缩容量到实际长度
pub fn (self: *Vec<T>) shrink_to_fit() void {
    if (self.len < self.capacity) {
        if (self.len == 0) {
            if (self.data != null) {
                free(self.data);
                self.data = null;
            }
            self.capacity = 0;
        } else {
            self.data = realloc(self.data, self.len * sizeof<T>()) as *T;
            self.capacity = self.len;
        }
    }
}

/// 释放Vec的内存
pub fn (self: *Vec<T>) drop() void {
    if (self.data != null) {
        free(self.data);
        self.data = null;
    }
    self.len = 0;
    self.capacity = 0;
}

// ============================================================================
// 辅助函数
// ============================================================================

extern fn sizeof<T>() int;
